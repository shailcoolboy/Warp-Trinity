///////////////////////////////////////////////////////////////////////////////
//
//      Project:  Aurora Module Generator version 2.2
//
//         Date:  $Date: 2004/11/08 16:19:26 $
//          Tag:  $Name: i+H-38+78751 $
//         File:  $RCSfile: idle_and_ver_gen.ejava,v $
//          Rev:  $Revision: 1.1.6.2 $
//
//      Company:  Xilinx
// Contributors:  R. K. Awalt, B. L. Woodard, N. Gulstone
//
//   Disclaimer:  XILINX IS PROVIDING THIS DESIGN, CODE, OR
//                INFORMATION "AS IS" SOLELY FOR USE IN DEVELOPING
//                PROGRAMS AND SOLUTIONS FOR XILINX DEVICES.  BY
//                PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
//                ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
//                APPLICATION OR STANDARD, XILINX IS MAKING NO
//                REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
//                FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE
//                RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY
//                REQUIRE FOR YOUR IMPLEMENTATION.  XILINX
//                EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH
//                RESPECT TO THE ADEQUACY OF THE IMPLEMENTATION,
//                INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
//                REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE
//                FROM CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES
//                OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
//                PURPOSE.
//
//                (c) Copyright 2004 Xilinx, Inc.
//                All rights reserved.
//
///////////////////////////////////////////////////////////////////////////////
//
//  IDLE_AND_VER_GEN
//
//  Author: N. Gulstone, B.Woodard
//          Xilinx - Embedded Networking System Engineering Group
//
//  Description: the IDLE_AND_VER_GEN module generates idle sequences and
//               verification sequences for the Aurora channel.  The idle sequences
//               are constantly generated by a pseudorandom generator and a counter
//               to make the sequence Aurora compliant.  If the gen_ver signal is high,
//               verification symbols are added to the mix at appropriate intervals
//
//               This module supports 1 4-byte lane designs
//

`timescale 1 ns / 10 ps

module IDLE_AND_VER_GEN
(
    //Channel Init SM Interface
    GEN_VER,

    DID_VER,


    //Aurora Lane Interface
    GEN_A,
    GEN_K,
    GEN_R,
    GEN_V,


    //System Interface
    RESET,
    USER_CLK
);

`define DLY #1


//***********************************Port Declarations*******************************


    //Channel Init SM Interface
    input              GEN_VER;

    output             DID_VER;


    //Aurora Lane Interface
    output             GEN_A;
    output  [0:3]      GEN_K;
    output  [0:3]      GEN_R;
    output  [0:3]      GEN_V;


    //System Interface
    input              RESET;
    input              USER_CLK;


//*********************************External Register Declarations*********************

    reg                DID_VER;

//********************************Internal Register Declarations**********************

    reg     [0:3]      lfsr_reg;
    reg     [0:2]      down_count_r;
    reg     [0:2]      downcounter_r;
    reg                prev_cycle_gen_ver_r;

//*********************************Wire Declarations**********************************

    wire    [0:3]      gen_k_c;
    wire    [0:3]      gen_r_c;
    wire               ver_counter_c;
    wire    [0:3]      gen_k_flop_c;
    wire    [0:3]      gen_r_flop_c;
    wire               gen_a_flop_c;
    wire               downcounter_done_c;
    wire               gen_ver_edge_c;
    wire               recycle_gen_ver_c;
    wire               insert_ver_c;

//*********************************Main Body of Code**********************************


    //____________________________Random Pattern Generation_________________________

    // Use an LFSR to create pseudorandom patterns.  This is a 4-bit LFSR from
    // the Aurora 401.  Taps on bits 0 and 3 are XORed with the OR of bits 1:3
    // to make the input to the register.

    initial
        lfsr_reg = 0;

    always @(posedge USER_CLK) begin
        lfsr_reg[0] <= lfsr_reg[1];
        lfsr_reg[1] <= lfsr_reg[2];
        lfsr_reg[2] <= lfsr_reg[3];
        lfsr_reg[3] <= (lfsr_reg[0] ^ lfsr_reg[3] ^ (~| lfsr_reg[1:3]));
    end

    // A constants generator is used to limit the downcount range to values
    // between 3 and 6 (4 to 7 clocks, 16 to 28 bytes).

    initial
        down_count_r = 0;

    always @(posedge USER_CLK) begin
        case (lfsr_reg[1:3])
            3'b000: down_count_r <= 3;
            3'b001: down_count_r <= 4;
            3'b010: down_count_r <= 5;
            3'b011: down_count_r <= 6;
            3'b100: down_count_r <= 3;
            3'b101: down_count_r <= 4;
            3'b110: down_count_r <= 5;
            3'b111: down_count_r <= 6;
        endcase
    end

    // Use a downcounter to determine when A's should be added to the idle pattern.
    // Load the counter with the 3 least significant bits of the lfsr whenever the
    // counter reaches 0.

    initial
        downcounter_r = 0;

    always @(posedge USER_CLK) begin
        if (RESET) downcounter_r <= `DLY 0;
        else if (downcounter_done_c) downcounter_r <= `DLY down_count_r;
        else downcounter_r <= `DLY downcounter_r - 1;
    end

    assign downcounter_done_c = (downcounter_r == 3'b000);


    // The LFSR's pseudo random patterns are also used to generate the sequence of
    // K and R characters that make up the rest of the idle sequence.  Note that
    // R characters are used whenever K characters are not.

    assign gen_r_c =  lfsr_reg;
    assign gen_k_c = ~lfsr_reg;


    //_____________________Verification Sequence Generation________________________

    // Use a counter to generate the verification sequence every 64 bytes
    // (16 clocks), starting from when verification is enabled.

    always @(posedge USER_CLK)
        prev_cycle_gen_ver_r <= `DLY GEN_VER;


    // Detect the positive edge of the GEN_VER signal.

    assign gen_ver_edge_c = GEN_VER & !prev_cycle_gen_ver_r;


    // If GEN_VER is still high after generating a verification sequence,
    // indicate that the gen_ver signal can be generated again.

    assign recycle_gen_ver_c = DID_VER & GEN_VER;


    // Prime the verification counter SRL16 with a 1.  When this 1 reaches the end
    // of the register, it will become the gen_ver_word signal.  Prime the counter
    // only if there was a positive edge on GEN_VER to start the sequence, or if
    // the sequence has just ended and another must be generated.

    assign insert_ver_c = gen_ver_edge_c | recycle_gen_ver_c;


    // Main Body of the verification counter.  It is implemented as a shift register
    // made from an SRL16.  The register is 15 cycles long, and operates by
    // taking the 1 from the insert_ver_c signal and passing it though its stages.

    // synthesis translate_off
    defparam ver_counter_i.INIT = 16'h0000;
    // synthesis translate_on

    SRL16 ver_counter_i
    (
        .Q(ver_counter_c),
        .A0(1'b0),
        .A1(1'b1),
        .A2(1'b1),
        .A3(1'b1),
        .CLK(USER_CLK),
        .D(insert_ver_c)
    );


    // Generate the 4 bytes of the verification sequence on the cycle after
    // the verification counter reaches '15'.  Also signals that the verification
    // sequence has been generated.

    always @(posedge USER_CLK)
        DID_VER <= `DLY ver_counter_c;


    //_________________________________Output Signals_____________________________

    // Assert GEN_V in the LSBytes of each lane when DID_VER is asserted.  We use
    // a seperate register for each output to provide enough slack to allow the
    // Global logic to communicate with all lanes without causing timing problems.

    assign  GEN_V[0] = 1'b0;

    // synthesis translate_off
    defparam gen_v_flop_1_i.INIT = 1'b0;
    // synthesis translate_on

    FD gen_v_flop_1_i
    (
        .D(recycle_gen_ver_c),
        .C(USER_CLK),
        .Q(GEN_V[1])
    );

    // synthesis translate_off
    defparam gen_v_flop_2_i.INIT = 1'b0;
    // synthesis translate_on

    FD gen_v_flop_2_i
    (
        .D(recycle_gen_ver_c),
        .C(USER_CLK),
        .Q(GEN_V[2])
    );

    // synthesis translate_off
    defparam gen_v_flop_3_i.INIT = 1'b0;
    // synthesis translate_on

    FD gen_v_flop_3_i
    (
        .D(recycle_gen_ver_c),
        .C(USER_CLK),
        .Q(GEN_V[3])
    );


    // Assert GEN_A in the MSByte of each lane when the GEN_A downcounter reaches 0.
    // Note that the signal has a register for each output for the same reason as the
    // GEN_V signal.  GEN_A is ignored when it collides with other non-idle
    // generation requests at the Aurora Lane, but we qualify the signal with
    // the gen_ver_word_1_r signal so it does not overwrite the K used in the
    // MSByte of the first word of the Verification sequence.

    assign  gen_a_flop_c    =   downcounter_done_c & !recycle_gen_ver_c;


    // synthesis translate_off
    defparam gen_a_flop_0_i.INIT = 1'b0;
    // synthesis translate_on

    FD gen_a_flop_0_i
    (
        .D(gen_a_flop_c),
        .C(USER_CLK),
        .Q(GEN_A)
    );

    // Assert GEN_K in the MSByte when the lfsr dictates. Turn off the assertion if an
    // /A/ symbol is being generated on the byte.  Assert the signal without qualifications
    // if GEN_V is asserted.  Assert GEN_K in the LSBytes when the lfsr dictates.
    // There are no qualifications because only the GEN_R signal can collide with it, and
    // this is prevented by the way the gen_k_c signal is generated.  All other GEN signals
    // will override this signal at the AURORA_LANE.

    assign gen_k_flop_c[0] = (gen_k_c[0] & !downcounter_done_c) | recycle_gen_ver_c;


    // synthesis translate_off
    defparam gen_k_flop_0_i.INIT = 1'b0;
    // synthesis translate_on

    FD gen_k_flop_0_i
    (
        .D(gen_k_flop_c[0]),
        .C(USER_CLK),
        .Q(GEN_K[0])
    );

    assign gen_k_flop_c[1] = gen_k_c[1];

    // synthesis translate_off
    defparam gen_k_flop_1_i.INIT = 1'b0;
    // synthesis translate_on

    FD gen_k_flop_1_i
    (
        .D(gen_k_flop_c[1]),
        .C(USER_CLK),
        .Q(GEN_K[1])
    );

    assign gen_k_flop_c[2] = gen_k_c[2];

    // synthesis translate_off
    defparam gen_k_flop_2_i.INIT = 1'b0;
    // synthesis translate_on

    FD gen_k_flop_2_i
    (
        .D(gen_k_flop_c[2]),
        .C(USER_CLK),
        .Q(GEN_K[2])
    );

    assign gen_k_flop_c[3] = gen_k_c[3];

    // synthesis translate_off
    defparam gen_k_flop_3_i.INIT = 1'b0;
    // synthesis translate_on

    FD gen_k_flop_3_i
    (
        .D(gen_k_flop_c[3]),
        .C(USER_CLK),
        .Q(GEN_K[3])
    );


    // Assert GEN_R in the MSByte when the lfsr dictates.  Turn off the assertion if an
    // /A/ symbol, or the first verification word is being generated.  Assert GEN_R in the
    // LSByte when the lfsr dictates, with no qualifications (same reason as the GEN_K LSByte).

    assign gen_r_flop_c[0] = gen_r_c[0] & !downcounter_done_c & !recycle_gen_ver_c;


    // synthesis translate_off
    defparam gen_r_flop_0_i.INIT = 1'b0;
    // synthesis translate_on

    FD gen_r_flop_0_i
    (
        .D(gen_r_flop_c[0]),
        .C(USER_CLK),
        .Q(GEN_R[0])
    );

    assign gen_r_flop_c[1] = gen_r_c[1];

    // synthesis translate_off
    defparam gen_r_flop_1_i.INIT = 1'b0;
    // synthesis translate_on

    FD gen_r_flop_1_i
    (
        .D(gen_r_flop_c[1]),
        .C(USER_CLK),
        .Q(GEN_R[1])
    );

    assign gen_r_flop_c[2] = gen_r_c[2];

    // synthesis translate_off
    defparam gen_r_flop_2_i.INIT = 1'b0;
    // synthesis translate_on

    FD gen_r_flop_2_i
    (
        .D(gen_r_flop_c[2]),
        .C(USER_CLK),
        .Q(GEN_R[2])
    );

    assign gen_r_flop_c[3] = gen_r_c[3];

    // synthesis translate_off
    defparam gen_r_flop_3_i.INIT = 1'b0;
    // synthesis translate_on

    FD gen_r_flop_3_i
    (
        .D(gen_r_flop_c[3]),
        .C(USER_CLK),
        .Q(GEN_R[3])
    );

endmodule
